### LECTURE 1 ###

# Hey!  Welcome to RStudio!  Let's take a look at what R can do, shall we?

# R is an interpreted language (unlike Processing you don't have to compile
# anything) which means we can type stuff straight into the console to be executed
# immediately.  It's a cliched example, but R can be used "like a calculator".  
# Mathematical functions abound by default, so you can do stuff like this:

x <- 3 + sqrt(100) # Evaluate and assign 3 + 10 to variable x (note the "<-" for assignment)
print(x)
x                  # Just writing the name of a variable is like calling print()

y <- 7.32*x / exp(2)
y

my.variable <- x^5 # Unlike processing, "." has no special significance in R.
# It can be used like any other character when naming variables.
my.variable

# We'll have plenty of time this quarter to dig into the actual mathematical
# functions we need when we need them.  For now, let's load up some data and 
# start looking at it.  Let's grab some data that I've put up at 
# http://www.jakeporway.com/teaching/data/snf_11_2011_1.csv 
#
# R can handle a lot of different file formats (XML, JSON, binary) from both
# your local computer as well as the web.
# Let's start with a staple of the statistics world, the "comma separated value" (CSV)
# file, which consists of, as you might guess, values separated by commas.
# To get the data into R we'll use the "read.csv" function:

data <- read.csv("http://www.jakeporway.com/teaching/data/snf_11_2011_1.csv", header=TRUE, as.is=TRUE)

# Here we're telling R to go off and fetch the file at that URL using the function 
# read.csv (which tells R to expect comma separated values).  header=TRUE just tells
# R that the first row contains the names of the columns and as.is=TRUE tells R
# not to do any funky preprocessing to the data.

# So what is this data?  We can get a readout of the first 6 rows by using the head()
# function:
head(data)  # first 6 lines

# Hmm, "crime.suspected", "frisked", "searched", "precinct".  If I didn't know better, I'd say
# this was police data.  And so it is!  It's a record of every Stop and Frisk that the NYPD
# did in November 2011.  Neat!  In a sort of dark and voyeuristic way.  Let's talk about
# these variables:

#                time                crime.suspected frisked searched precinct sex race age
#1 2011-11-01 00:00:00 CSCS                                 0        0        9   F    Z  55
#2 2011-11-01 00:01:00 MISD                                 1        1       14   M    B  36
#3 2011-11-01 00:01:00 MISD                                 1        1       14   M    B  38
#4 2011-11-01 00:01:00  FEL                                 1        0       53   M    Q  29
#5 2011-11-01 00:05:00 FEL                                  1        0       14   F    B  33
#6 2011-11-01 00:05:00 FEL                                  1        0       14   F    B  18

# time:  Looks like the time down to the minute.
# crime.suspected:  Some code for the crime suspected
# frisked: Whether the suspect was frisked or not
# searched:  Whether the suspect was searched or not
# precinct:  The precinct this crime occurred in
# sex: Sex of the suspect
# race:  Race of the suspect
# age:  Age of the suspect
# day:  The day in November the Stop and Frisk happened
# arrested:  If the suspect was arrested or not


# Note that many of the variables are QUALITATIVE variables
# (non-numeric).  Age is  the only meaningfully QUANTITATIVE variable (because
# the other numeric variables could just as easily be replaced with labels like "Yes", "No",
# or "Brooklyn Precinct".  They don't represent numbers in the sense that one is greater
# than another or they fit on a spectrum somehow).

# A SUPER SERIOUS MEGA IMPORTANT THING TO NOTE THAT YOU REALLY NEED TO THINK
# ABOUT ALWAYS (NO, I'M SERIOUS, THIS IS PROBABLY ONE OF THE MOST IMPORTANT THINGS
# YOU NEED TO KEEP IN MIND, ALWAYS AND FOREVER):
#
# Data always, ALWAYS has some human element.  Every entry in this dataset, every impersonal
# row of numbers, represents a person, a real, living, breathing person who lives in this city
# and who was confronted by the police.  They may have been frisked, they may have been
# searched, they may have been arrested.  They may be in prison right now.  They have families.
# They have friends.  You may know them.  You may not.  They may have been afraid.
# They may not.  No matter what, they are humans.
#
# It is critically, critially, CRITICALLY important that we never forget
# this fact.  We must strive, even as we summarize numbers, never to reduce the individual.
# I debated using a less-sensitive dataset for this class, but I don't want you to 
# shy from charged datasets.  I just want you to be thoughtful, caring, and to remember
# that, above all, we are dealing with real, living, breathing humans here.  
# More on this next class...

# OK, with that soap box out of the way, let's get back to the data. First off, since it's
# our first class, let's show off with R a bit.  With just a couple of lines of code,
# we can:

# Look at Stop and Frisks by race,
barplot(rev(sort(table(data$race))), main="Stop and Frisks by Race")

# the number of Stop and Frisks each day,
plot(table(data$day), type='l', ylab="# Stops", xlab="Day", main="Stops by day")

# And even look at Stop and Frisks broken down by gender and race
library(lattice)
under100 <- data[data$age < 100,]
densityplot(~age | race, under100, groups=sex, plot.points=F)

# Cool!  Do you need to know how all that just happened?  No.
#I don't want you to walk away from this understanding every one of those
# commands, but what I hope you take away is that visualizing
# data in R is *super simple*.  We really only needed ONE command to create a set of
# graphs with overlaid lines, broken down by gender and sex.  Think of what
# this would have taken in Processing.  So much code!  Granted, this isn't presentation-
# worthy, but it's enough that we can start to look at the data, and that's what's important.

# OK, we get it - R is cool.  Nice graphs.  Let's actually walk through some of the nitty gritty of
# working with R.

# HELP!  
#
# Eventually you'll forget what a function does or what it's named.  Your
# best friend is "?"
?head

# If you can't remember the name of a function, you can try help.search
help.search("head")

# R's open source, if you recall, so you can see the source by typing a function
# without the parens:
ncol #pretty much what we'd expect

# Let's get a quick sense of the size of this data:

tail(data) # last 6 lines

dim(data)  # dim() stands for "dimension" and gives you the rows and columns

nrow(data)

ncol(data)

# A NEAT THING WE SHOULD STOP AND NOTICE 
#
# By now you should start to get the hint that R is a "functional" programming language.
# This means that, unlike Processing, which figures heavily on objects, R's unit
# of currency is the function (like print(), head(), dim(), etc.)  You can even 
# use functions within functions, kind of like UNIX pipes:
# dim(head(data))
#
# The Processing equivalent might look like:
# data.head().dim()
#
# We'll see later how conceptually important it will be to be able to call print()
# on almost anything...

# Let's talk a little about how R structures this data.  What we've been dealing
# with, this big table of data, is called a "data frame" (a special data type in R).
# "Data frames" are tables
# where the columns can all be different types 
# We can ask to look at rows, columns, or individual entries in the table:

data[1,1] # the first row in the first column (R is 1-indexed, unlike Processing!!!)
data[10,]  # 10th row 
data[,2]  # second column
data[10000,10] # the day of the 10000th Stop and Frisk
#data[101] # Common mistake!  R knows you want row 101 but doesn't know which columns to return!  You have to specify a column, even if it's all of them by omission.

# It can be a pain in the butt to remember which column number corresponds to which
# variable, so we can also use names to refer to columns:

data[10000,"day"]

# You can get a single column using the $ operator
just_the_day <- data$day

# attach()
# When we're referencing columns a lot, it can be annoying to constantly type "data$",
# so you can use attach() to have R create a set of variables, one for each column,
# so you can refer to them by name:
sex # ERROR!
# Error: object 'sex' not found
data$sex
attach(data)
sex

# DATA TYPES
#
# Just like variable types in Processing (String, int, boolean), R
# has some basic data types.  The ones you'll run across most commonly are
# characters (Strings in Processing), numerics (ints, floats, doubles in 
# Processing) and logicals, (booleans in Processing). 

character.variable <- "Jake"
numeric.variable <- 3.1415
logical.variable <- TRUE

# The class() function will tell you what type R has cast
# a variable to (since we never tell it by default).
class(character.variable)

# R also has lists, vectors, matrices, data frames, and factors built-in (more 
# on those in a bit).  
head(data)

# What types are our columns?
class(data$time)
class(data$crime.suspected)
class(data$precinct)

# VECTORS
# Our data is in a data frame, where each column is a "vector" in R (one of
# the other built-in data types).  Vectors are
# one-dimensional lists of objects that are all the same type.  These are just like
# arrays in Processing.  We created a copy of the day column in just_the_days.  If we wanted
# to, we could access individual elements of the vector.  Unlike the data frame, we don't
# have to specify a column because vectors are one-dimensional.

just_the_days[100]

# A LITTLE LESSON ON VECTORS
#
# OK, we can't just introduce vectors and move on because they're SO common
# and SO cool, so let's take a moment to talk about them.

# One thing we're going to see a lot of is creating our own vectors.
# The "c()" function "concatenates" objects of the same type (remember, vectors have
# to be formed from objects of the same type)
drinks.per.week <- c(3, 4, 9, 10, 2, 5)

# the ":" is awesome for creating sequences

one.to.ten <- 1:10

# we can also create cool sequences with the seq() and rep() functions

up.by.five <- seq(1, 100, 5)
sell.it <- rep("R!", 10)

# You can check their lengths...
length(sell.it)

# Find their minimum and maximum values...
min(up.by.five)
max(up.by.five)

# add 'em up...
sum(up.by.five)

# get the unique values back...
unique(up.by.five)

# Or sort them
sort(c(5, 3, 1, 6, 9))

# So, back to Stop and Frisk, how many unique sexes do you expect?  How many are there?
unique(sex)

# How many precincts are there?
max(precinct)

# Can we guarantee the max gives us the number of precincts?  If not, what would be a better
# way to count the precincts?
length(unique(precinct)) # nesting!

# INDEXING
# A big reason vectors are so awesome is that we can use them to index rows
# and columns in our data frames.  So far we've selected single rows, columns,
# and elements, but what if we want to get a set of results?

data[1:10, ] # first 10
data[c(1, 3, 5), ] #first, third, fifth
data[,c("frisked","searched", "arrested")]  # frisked, searched, and arrested columns
data[,-c(2:5)]  # whoa, negative indexing!  "all but" columns 2 through 5

# (P.S. You'd have to write dirty for loops in Processing for all of these.  R
#  abhors a for loop (though we'll definitely use them later) and prefers to 
#  think of operations as "vectorized", i.e. using vectors to apply funcions
#  across sets of data)

# Lastly, one super important function we're going to see is table().  table() goes
# through and returns the number of times each element appears in a vector.

stops_by_day <- table(day)  # Number of stops each day.  
plot(stops_by_day, type="l")  # Plot it

# Ah!  That's how we got that plot.  

# Let's lastly look at how powerful nesting functions is using our first show-off graph.
# The command is barplot(rev(sort(races))).  When you nest functions,
# they operate inside out, passing the results of each inner function to the outer function,
# so what this command does is:
# 1.  sort(races):  Sorts the counts of races
# 2.  rev(sort(races)):  Because sort sorts in increasing order, reverses that result
# 3.  barblot(rev(sort(races)):  Makes a barplot of the sorted, reversed result.
#
# We could have split this up by assigning the intermediate results to variables, but
# that's not as sexy:
# sorted_races <- sort(races)
# reversed_races <- rev(sorted_races)
# barplot(reversed_races)


